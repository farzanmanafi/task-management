
# nginx/nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream app {
        server app:3000;
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=100r/m;
    limit_req_zone $binary_remote_addr zone=auth:10m rate=20r/m;

    server {
        listen 80;
        server_name localhost;

        # Security headers
        add_header X-Frame-Options "DENY" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # Gzip compression
        gzip on;
        gzip_vary on;
        gzip_min_length 1024;
        gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

        # Static files
        location /uploads {
            alias /var/www/uploads;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # API routes
        location /api {
            limit_req zone=api burst=50 nodelay;
            proxy_pass http://app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Auth routes (more restrictive)
        location /api/v1/auth {
            limit_req zone=auth burst=10 nodelay;
            proxy_pass http://app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Health check
        location /health {
            proxy_pass http://app;
            access_log off;
        }

        # Default route
        location / {
            proxy_pass http://app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}

# scripts/build.sh
#!/bin/bash

# Build script for production

set -e

echo "Building Task Management API..."

# Install dependencies
npm ci --only=production

# Build application
npm run build

# Run tests
npm run test:coverage:ci

# Create necessary directories
mkdir -p uploads logs

echo "Build completed successfully!"

# scripts/deploy.sh
#!/bin/bash

# Deployment script

set -e

echo "Deploying Task Management API..."

# Pull latest changes
git pull origin main

# Build Docker image
docker build -t task-management-api .

# Stop existing containers
docker-compose down

# Start new containers
docker-compose up -d

# Wait for services to be ready
sleep 30

# Run health check
curl -f http://localhost:3000/health || exit 1

echo "Deployment completed successfully!"

# scripts/dev.sh
#!/bin/bash

# Development setup script

set -e

echo "Setting up development environment..."

# Install dependencies
npm install

# Start development environment
docker-compose -f docker-compose.dev.yml up -d

# Wait for database to be ready
sleep 10

# Run migrations
npm run migration:run

# Start development server
npm run start:dev

# package.json scripts (add these to existing scripts)
{
  "scripts": {
    "docker:build": "docker build -t task-management-api .",
    "docker:run": "docker-compose up -d",
    "docker:dev": "docker-compose -f docker-compose.dev.yml up -d",
    "docker:stop": "docker-compose down",
    "docker:logs": "docker-compose logs -f",
    "health:check": "curl -f http://localhost:3000/health",
    "build:prod": "./scripts/build.sh",
    "deploy": "./scripts/deploy.sh",
    "dev:setup": "./scripts/dev.sh"
  }
}

# health-check.js (for Docker health check)
const http = require('http');

const options = {
  hostname: 'localhost',
  port: 3000,
  path: '/health/live',
  method: 'GET',
  timeout: 3000
};

const req = http.request(options, (res) => {
  if (res.statusCode === 200) {
    process.exit(0);
  } else {
    process.exit(1);
  }
});

req.on('error', () => {
  process.exit(1);
});

req.on('timeout', () => {
  req.destroy();
  process.exit(1);
});

req.end();